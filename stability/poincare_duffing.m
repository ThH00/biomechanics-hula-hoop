% generated by chatGPT

function poincare_duffing()
    % Parameters
    delta = 0.2;
    alpha = -1;
    beta = 1;
    gamma = 0.3;
    omega = 1.2;

    % Time span
    T = 2*pi/omega;  % forcing period
    N_cycles = 10000;  % number of cycles to simulate
    tspan = [0 N_cycles*T];

    % Initial condition: [x, y] = [position, velocity]
    x0 = [0.1; 0];

    % Solve ODE
    options = odeset('RelTol',1e-8,'AbsTol',1e-10);
    [~, ~, poincare_points] = compute_poincare(x0, tspan, T, ...
        @(t, x) duffing(t, x, delta, alpha, beta, gamma, omega), options);

    % Plot the Poincaré map
    figure;
    plot(poincare_points(:,1), poincare_points(:,2), 'k.', 'MarkerSize', 5);
    xlabel('x');
    ylabel('y');
    title('Poincaré Map of Forced Duffing Oscillator');
    grid on;
end

function dxdt = duffing(t, x, delta, alpha, beta, gamma, omega)
    dxdt = [x(2);
            -delta*x(2) - alpha*x(1) - beta*x(1)^3 + gamma*cos(omega*t)];
end

function [t_all, x_all, poincare_points] = compute_poincare(x0, tspan, T, ode_func, options)
    % Integrate and sample solution stroboscopically every T seconds
    t_current = 0;
    x_current = x0;
    t_all = [];
    x_all = [];
    poincare_points = [];

    while t_current < tspan(2)
        t_next = t_current + T;
        [t_sol, x_sol] = ode45(ode_func, [t_current t_next], x_current, options);
        
        % Interpolate to get state at exactly t_next
        x_interp = interp1(t_sol, x_sol, t_next);
        
        % Store the result
        t_all = [t_all; t_next];
        x_all = [x_all; x_interp];
        poincare_points = [poincare_points; x_interp];  % x_interp is [x, y]
        
        % Update initial conditions
        t_current = t_next;
        x_current = x_interp';
    end
end
