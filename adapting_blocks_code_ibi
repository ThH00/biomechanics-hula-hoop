# iteration-by-iteration-solution

import numpy as np
import math
import time
import os
import argparse
from scipy.signal import argrelextrema
import scipy.io

start_time = time.time()

# optaining certain parametric arguments from an input file
# def parse_args():
#     parser = argparse.ArgumentParser(description='Process some integers and floats.')
#     parser.add_argument('mu_s', type=float, help='static friction coefficient (float)')
#     parser.add_argument('mu_s', type=float, help='kinetic friction coefficient (float)')
#     parser.add_argument('--output_path', '-o', type=str, help='Output path (optional)')
    
#     args = parser.parse_args()
    
#     return args.mu_s, args.mu_k, args.output_path

# mu_s, mu_k, output_path = parse_args()

###############################
mu_s = 1
mu_k = 0.3
output_path = os.path.join(os.getcwd(), "outputs/multiple_solutions")
os.makedirs(output_path, exist_ok=True)
###############################

# Specify the maximum duration in hours for one run 
max_hours = 50

# Specify the maximum number of leaves beyond which the code will stop running
max_leaves = 4

# creating custom exceptions
class MaxNewtonIterAttainedError(Exception):
    """This exception is raised when the maximum number of Newton iterations is attained
      whilst the iterations have not yet converged and the solution was not yet obtained."""
    def __init__(self, message="This exception is raised when the maximum number of Newton iterations is attained."):
        self.message = message
        super().__init__(self.message)

class RhoInfInfiniteLoop(Exception):
    """This exception is raised when we have possibly entered in an infinite loop through updating rho_inf."""
    def __init__(self, message="This exception is raised when we have possibly entered in an infinite loop through updating rho_inf."):
        self.message = message
        super().__init__(self.message)

class MaxHoursAttained(Exception):
    """This exception is raised when the maximum number of run hours specified by the use is exceeded."""
    def __init__(self, message="This exception is raised when the maximum run time is exceeded."):
        self.message = message
        super().__init__(self.message)

class MaxLeavesAttained(Exception):
    """This exception is raised when the maximum number of run leaves specified by the use is exceeded."""
    def __init__(self, message="This exception is raised when the maximum number of leaves is exceeded."):
        self.message = message
        super().__init__(self.message)

# # Exception not initially present in ibi
# class NoBifurcationConvergence(Exception):
#     """This exception is raised when all leaves did not converge."""
#     def __init__(self, message="This exception is raised when all leaves did not converge."):
#         self.message = message
#         super().__init__(self.message)

class NoLocalMinima(Exception):
    def __init__(self, message="The distance between the hoop and the hip has less then 1 or more than 2 local minima."):
        super().__init__(message)

# f is an output file that logs failed runs
# it is saved in the directory containing the output file
directory_containing_output = os.path.dirname(output_path)
f = open(f"{directory_containing_output}/run_failures_log.txt",'a')

# g contains a sketch of the bifurcation map
g = open(f"{output_path}/bifurcation_map.txt",'w') 

# nondimensionalization parameters
l_nd = 1                    # m, length nondimensionalization paramter
m_nd = 1                    # kg, mass nondimensionalization parameter
a_nd = 9.81                 # m/(s**2), acceleration nondimensionalization parameter
t_nd = np.sqrt(l_nd/a_nd)   # s, time nondimensionalization parameter

# quantites following this line are nondimensional

# the motion of the first block is prescribed (acts like a base plate)
ndof = 6                    # total number of degress of freedom
gr = 9.81/a_nd              # gravitational acceleration

# simulation (time) parameters
# period of one oscillation in sec/cylcle
dtime = 2e-3/t_nd           # time step duration
ntime = 2000                # number of iterations
ntime_init = ntime          # saving the initial number of iterations to be completed, ntime can change
tf = ntime*dtime            # final time
t = np.linspace(0,tf,ntime) # time array

# hoop properties
m = 0.2/m_nd                # mass of hoop
R_hoop = 0.5/l_nd           # radius of hoop
It = 0.5*m*R_hoop**2        # rotational inertia of hoop about diameter
Ia = m*R_hoop**2            # rotational inertia of hoop about axis passing through center perp to hoop plane

# hip properties
R_hip = 0.2/l_nd            # radius of the hip

# the hip center is tracing an ellipse
# position of the bottom center of hip (bottom of hip axis)
x1bar_hip = 1*np.ones(ntime)*(t**2)/2
x2bar_hip = np.zeros(ntime)+0.1
xbar_hip = np.column_stack((x1bar_hip, x2bar_hip, np.zeros(ntime)))
# velocity of the bottom center of hip
v1bar_hip = 1*np.ones(ntime)*t
v2bar_hip = np.zeros(ntime)
vbar_hip = np.column_stack((v1bar_hip, v2bar_hip, np.zeros(ntime)))
# acceleration of the bottom center of hip
a1bar_hip = 1*np.ones(ntime)
a2bar_hip = np.zeros(ntime)
abar_hip = np.column_stack((a1bar_hip, a2bar_hip, np.zeros(ntime)))

# angular velocity and angular acceleration of hip
omega_hip = np.array([0,0,1])   # angular velocity of hip
alpha_hip = np.array([0,0,0])   # angular acceleration of hip

g.write(f"######\n Ruunning a simulation with the hip tracing a straight line:\n")
g.write(f"      abar_hip = {a1bar_hip[0]} Ex+ {a2bar_hip[0]} Ey.\n")
g.write(f"    The hip is rotating with an angular velocity omega_hip = {omega_hip}.\n")
g.write(f"    Total duration of simulation: {tf}.\n")

# constraint count
ng = 0          # number of constraints at position level
ngamma = 0      # number of constraints at velocity level
nN = 2          # number of gap distance constraints
nF = 4          # number of friction constraints
gammaF_lim = np.array([[0,1],[2,3]])    # connectivities of friction and normal forces
nX = 3*ndof+3*ng+3*ngamma+3*nN+2*nF     # total number of constraints with their derivative

# fixed basis vectors
E1 = np.array([1,0,0])
E2 = np.array([0,1,0])
E3 = np.array([0,0,1])

# generalized alpha parameters
MAXITERn = 20
MAXITERn_initial = MAXITERn # saving the initial value of MAXITERn # this was not initially present in ibi
r = 0.3
rho_inf = 0.5
rho_infinity_initial = rho_inf
# eq. 72
alpha_m = (2*rho_inf-1)/(rho_inf+1)
alpha_f = rho_inf/(rho_inf+1)
gama = 0.5+alpha_f-alpha_m
beta = 0.25*(0.5+gama)**2
tol_n = 1.0e-6              # error tolerance # this was not initially present in ibi

# coefficients of restitution
eN = 0                  # normal coefficient of restitution
eF = 0                  # friction coefficient of retitution

# mass matrix (constant)
Mdiag = np.array([m, m, m, It, It, Ia])
M = np.diag(Mdiag)

# applied forces (weight)
force = np.array([0, 0, -m*gr, 0, 0, 0])      # I removed gravity for now
# force = np.array([0, 0, 0, 0, 0, 0])

# discritization of tau value for finding minimizing one
n_tau = int(1/tol_n)

# get the saved lists of unique contacts
# define the path where the arrays were saved
unique_contacts_path = os.path.join(os.getcwd(), "unique_contacts")

# Load the arrays
unique_contacts_a = np.load(f'{unique_contacts_path}/unique_contacts_a.npy')
unique_contacts_b = np.load(f'{unique_contacts_path}/unique_contacts_b.npy')
unique_contacts_c = np.load(f'{unique_contacts_path}/unique_contacts_c.npy')
unique_contacts_d = np.load(f'{unique_contacts_path}/unique_contacts_d.npy')

def save_arrays():
    global q_save, u_save, X_save, gNdot_save, gammaF_save, AV_save

    file_name_q = str(f'{output_path}/q.mat')
    scipy.io.savemat(file_name_q,dict(q=q_save))

    file_name_u = str(f'{output_path}/u.mat')
    scipy.io.savemat(file_name_u,dict(u=u_save))

    file_name_x_save = str(f'{output_path}/x_save.mat')
    scipy.io.savemat(file_name_x_save,dict(X=X_save))

    file_name_xbar_hip = str(f'{output_path}/xbar_hip.mat')
    scipy.io.savemat(file_name_xbar_hip,dict(xbar_hip=xbar_hip))


    np.save(f'{output_path}/q_save.npy', q_save)
    np.save(f'{output_path}/u_save.npy', u_save)
    np.save(f'{output_path}/X_save.npy', X_save)
    np.save(f'{output_path}/gNdot_save.npy', gNdot_save)
    np.save(f'{output_path}/gammaF_save.npy', gammaF_save)
    np.save(f'{output_path}/AV_save.npy', AV_save)

    return


def get_minimizing_tau(q, xbar_hip):

    # center of hoop
    xbar_hoop = q[:3]
    # Euler angles of hoop
    psi = q[3]
    theta = q[4]
    phi = q[5]
    # Rotation matrices
    R1 = np.array([[np.cos(psi), np.sin(psi), 0],[-np.sin(psi), np.cos(psi), 0],[0, 0, 1]])
    R2 = np.array([[1, 0, 0],[0, np.cos(theta), np.sin(theta)],[0, -np.sin(theta), np.cos(theta)]])
    R3 = np.array([[np.cos(phi), np.sin(phi), 0],[-np.sin(phi), np.cos(phi), 0],[0, 0, 1]])
    # {E1, E2, E3} components
    e1 = np.transpose(R3@R2@R1)@E1
    e2 = np.transpose(R3@R2@R1)@E2

    # Create an array of possible tau values (step size < algorithm tolerance)
    tau = np.linspace(0, 2*np.pi, num=n_tau, endpoint=True)
    # I can find intervals containing the minima and then refine the discretization in these intervals (or use the bisection method)

    # Creating array of hoop points
    # # Reshape tau to (1000000, 1) to enable broadcasting
    u = np.cos(tau)[:, np.newaxis] * e1 + np.sin(tau)[:, np.newaxis] * e2  # Shape (1000000, 3)

    xM = xbar_hoop+R_hoop*u

    # Calculating the value of dH for each point
    dv = np.dot(xM,E3)
    temp = xM-dv[:, np.newaxis]*E3-xbar_hip
    # Compute the norm of each row
    dh = np.linalg.norm(temp, axis=1)

    # dv = np.zeros((n_tau,1))
    # dh = np.zeros((n_tau,1))
    # for i in range(n_tau):
    #     dv[i] = np.dot(xM[i,:],E3)
    #     temp = xM[i,:]-dv[i]*E3-xbar_hip
    #     # Compute the norm of each row
    #     dh[i] = np.linalg.norm(temp)

    # Find the minimizers of dh
    # Find local minima (less than neighbors)
    min_indices = argrelextrema(dh, np.less)[0]
    # Find the minizing value of tau
    minimizing_tau = tau[min_indices]

    return minimizing_tau

def get_contact_constraints(q,u,a,tau,xbar_hip,vbar_hip,abar_hip):
    # gets gap distance, slip speed functions and their gradients and derivatives at each contact

    # prev_gNdot = gNdot_save[iter-1,:]

    # center of hoop
    xbar_hoop = q[:3]
    vbar_hoop = u[:3]
    abar_hoop = a[:3]
    # Euler angles of hoop
    psi = q[3]
    theta = q[4]
    phi = q[5]
    psidot = u[3]
    thetadot = u[4]
    phidot = u[5]
    psiddot = a[3]
    thetaddot = a[4]
    phiddot = a[5]
    
    WN = np.zeros(ndof)
    WF = np.zeros((ndof,2))

    # maybe make these rotation matrices and vectors global

    # Rotation matrices
    R1 = np.array([[np.cos(psi), np.sin(psi), 0],[-np.sin(psi), np.cos(psi), 0],[0, 0, 1]])
    R2 = np.array([[1, 0, 0],[0, np.cos(theta), np.sin(theta)],[0, -np.sin(theta), np.cos(theta)]])
    R3 = np.array([[np.cos(phi), np.sin(phi), 0],[-np.sin(phi), np.cos(phi), 0],[0, 0, 1]])
    # {E1, E2, E3} components
    e1p = np.transpose(R1)@E1
    e1 = np.transpose(R3@R2@R1)@E1
    e2 = np.transpose(R3@R2@R1)@E2
    e3 = np.transpose(R3@R2@R1)@E3

    omega_hoop = psidot*E3+thetadot*e1p+phidot*e3

    e1pdot = np.cross(psidot*E3,e1p)
    e3dot = np.cross(omega_hoop,e3)

    alpha_hoop = psiddot*E3+thetaddot*e1p+phiddot*e3+thetadot*e1pdot+phidot*e3dot

    tau_dot = 0
    tau_ddot = 0

    u_corrotational = tau_dot*(-np.sin(tau)*e1+np.cos(tau)*e2)
    u_double_corrotational = tau_ddot*(-np.sin(tau)*e1+np.cos(tau)*e2)

    u = np.cos(tau)*e1+np.sin(tau)*e2
    udot = u_corrotational+np.cross(omega_hoop,u)
    uddot = u_double_corrotational+2*np.cross(omega_hoop,u_corrotational)+np.cross(omega_hoop,np.cross(omega_hoop,u))+np.cross(alpha_hoop,u)

    xM = xbar_hoop+R_hoop*u
    vM = vbar_hoop+R_hoop*udot
    aM = abar_hoop+R_hoop*uddot

    # vertical components of vector from hip center to point on hoop
    H = xM-xbar_hip-np.dot(xM-xbar_hip,E3)*E3
    H_dot = vM-vbar_hip-np.dot(vM-vbar_hip,E3)*E3
    H_ddot = aM-abar_hip-np.dot(aM-abar_hip,E3)*E3

    norm_H = np.linalg.norm(H)
    gN = norm_H-R_hip
    gNdot = np.dot(H,H_dot)/norm_H
    gNddot = (np.dot(H_dot,H_dot)+np.dot(H,H_ddot))/norm_H

    WN[0] = 2*np.dot(H,E1)
    WN[1] = 2*np.dot(H,E2)
    WN[2] = 0

    de1_dpsi = np.cos(phi)*(E2*np.cos(psi) - E1*np.sin(psi)) - np.cos(theta)*np.sin(phi)*(E1*np.cos(psi) + E2*np.sin(psi))
    de2_dpsi = - np.sin(phi)*(E2*np.cos(psi) - E1*np.sin(psi)) - np.cos(phi)*np.cos(theta)*(E1*np.cos(psi) + E2*np.sin(psi))
    de1_dtheta = np.sin(phi)*(E3*np.cos(theta) - np.sin(theta)*(E2*np.cos(psi) - E1*np.sin(psi)))
    de2_dtheta = np.cos(phi)*(E3*np.cos(theta) - np.sin(theta)*(E2*np.cos(psi) - E1*np.sin(psi)))
    de1_dphi = np.cos(phi)*(E3*np.sin(theta) + np.cos(theta)*(E2*np.cos(psi) - E1*np.sin(psi))) - np.sin(phi)*(E1*np.cos(psi) + E2*np.sin(psi))
    de2_dphi = - np.cos(phi)*(E1*np.cos(psi) + E2*np.sin(psi)) - np.sin(phi)*(E3*np.sin(theta) + np.cos(theta)*(E2*np.cos(psi) - E1*np.sin(psi)))

    dxM_dpsi = np.cos(tau)*de1_dpsi+np.sin(tau)*de2_dpsi
    dxM_dtheta = np.cos(tau)*de1_dtheta+np.sin(tau)*de2_dtheta
    dxM_dphi = np.cos(tau)*de1_dphi+np.sin(tau)*de2_dphi

    WN[3] = 2*np.dot(H,dxM_dpsi-np.dot(dxM_dpsi,E3)*E3)
    WN[4] = 2*np.dot(H,dxM_dtheta-np.dot(dxM_dtheta,E3)*E3)
    WN[5] = 2*np.dot(H,dxM_dphi-np.dot(dxM_dphi,E3)*E3)

    # # comparing with previous values
    # different constraint formulation: there is a scaling difference in WN
    # WN0 = np.zeros((1,ndof))

    # gN0 = -R_hip + (xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    # gNdot0   = phidot*(1.0*R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.cos(tau) + (-np.sin(phi)*np.cos(psi)*np.cos(theta) - np.sin(psi)*np.cos(phi))*np.sin(tau))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]) + 1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.cos(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.sin(tau))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]))/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + psidot*(1.0*R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.cos(psi)*np.cos(theta) - np.sin(psi)*np.cos(phi))*np.cos(tau))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]) + 1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]))/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + thetadot*(1.0*R_hoop*(np.sin(phi)*np.sin(psi)*np.sin(theta)*np.cos(tau) + np.sin(psi)*np.sin(tau)*np.sin(theta)*np.cos(phi))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]) + 1.0*R_hoop*(-np.sin(phi)*np.sin(theta)*np.cos(psi)*np.cos(tau) - np.sin(tau)*np.sin(theta)*np.cos(phi)*np.cos(psi))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]))/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + vbar_hip[0]*(-1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) + 1.0*xbar_hip[0] - 1.0*xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + vbar_hip[1]*(-1.0*R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + 1.0*xbar_hip[1] - 1.0*xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + 1.0*vbar_hip[2]*xbar_hip[2]/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + vbar_hoop[0]*(1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - 1.0*xbar_hip[0] + 1.0*xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + vbar_hoop[1]*(1.0*R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - 1.0*xbar_hip[1] + 1.0*xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    # gNddot0 = 1.0*R_hoop*phidot**2*(-R_hoop*(((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.cos(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.sin(tau))*(-R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]) + ((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.cos(tau) - (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.sin(tau))*(-R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]))**2/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**1.5 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.cos(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.sin(tau))**2 + R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.cos(tau) - (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.sin(tau))**2 - ((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*(R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1]) - ((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau))*(R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0]))/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**0.5) + 1.0*R_hoop*psidot**2*(-R_hoop*(((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*(-R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]) - ((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau))*(-R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]))*(-((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*(R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0]) + ((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau))*(R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1]))/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**1.5 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))**2 + R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau))**2 - ((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*(R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1]) - ((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau))*(R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0]))/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**0.5) + 1.0*R_hoop*thetadot**2*(np.sin(phi)*np.cos(tau) + np.sin(tau)*np.cos(phi))*(-R_hoop*(-(-R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])*np.cos(psi) + (-R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])*np.sin(psi))*((R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])*np.cos(psi) - (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])*np.sin(psi))*(np.sin(phi)*np.cos(tau) + np.sin(tau)*np.cos(phi))*np.sin(theta)**2/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**1.5 + (R_hoop*(np.sin(phi)*np.cos(tau) + np.sin(tau)*np.cos(phi))*np.sin(psi)**2*np.sin(theta)**2 + R_hoop*(np.sin(phi)*np.cos(tau) + np.sin(tau)*np.cos(phi))*np.sin(theta)**2*np.cos(psi)**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])*np.cos(psi)*np.cos(theta) - (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])*np.sin(psi)*np.cos(theta))/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**0.5) + abar_hip[0]*(-1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) + 1.0*xbar_hip[0] - 1.0*xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + abar_hip[1]*(-1.0*R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + 1.0*xbar_hip[1] - 1.0*xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + 1.0*abar_hip[2]*xbar_hip[2]/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + abar_hoop[0]*(1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - 1.0*xbar_hip[0] + 1.0*xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + abar_hoop[1]*(1.0*R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - 1.0*xbar_hip[1] + 1.0*xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + phiddot*(1.0*R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.cos(tau) + (-np.sin(phi)*np.cos(psi)*np.cos(theta) - np.sin(psi)*np.cos(phi))*np.sin(tau))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]) + 1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.cos(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.sin(tau))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]))/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + psiddot*(1.0*R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.cos(psi)*np.cos(theta) - np.sin(psi)*np.cos(phi))*np.cos(tau))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]) + 1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]))/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + thetaddot*(1.0*R_hoop*(np.sin(phi)*np.sin(psi)*np.sin(theta)*np.cos(tau) + np.sin(psi)*np.sin(tau)*np.sin(theta)*np.cos(phi))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]) + 1.0*R_hoop*(-np.sin(phi)*np.sin(theta)*np.cos(psi)*np.cos(tau) - np.sin(tau)*np.sin(theta)*np.cos(phi)*np.cos(psi))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]))/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + 1.0*vbar_hip[0]**2*((-R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])*(R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**1.5 + (xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**(-0.5)) + 1.0*vbar_hip[1]**2*((-R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])*(R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**1.5 + (xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**(-0.5)) + 1.0*vbar_hip[2]**2*(-xbar_hip[2]**2/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**1.5 + (xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**(-0.5)) + 1.0*vbar_hoop[0]**2*((-R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])*(R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**1.5 + (xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**(-0.5)) + 1.0*vbar_hoop[1]**2*((-R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])*(R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**1.5 + (xbar_hip[2]**2 + (R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) - (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + xbar_hip[1] - xbar_hoop[1])**2 + (R_hoop*((np.sin(phi)*np.cos(psi) + np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.cos(tau)) + xbar_hip[0] - xbar_hoop[0])**2)**(-0.5))

    # WN0[0,0] = (1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - 1.0*xbar_hip[0] + 1.0*xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    # WN0[1,0] = (1.0*R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - 1.0*xbar_hip[1] + 1.0*xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    # WN0[2,0] = 0
    # WN0[3,0] = (1.0*R_hoop*((np.sin(phi)*np.sin(psi) - np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.cos(psi)*np.cos(theta) - np.sin(psi)*np.cos(phi))*np.cos(tau))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]) + 1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]))/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    # WN0[4,0] = (1.0*R_hoop*(np.sin(phi)*np.sin(psi)*np.sin(theta)*np.cos(tau) + np.sin(psi)*np.sin(tau)*np.sin(theta)*np.cos(phi))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]) + 1.0*R_hoop*(-np.sin(phi)*np.sin(theta)*np.cos(psi)*np.cos(tau) - np.sin(tau)*np.sin(theta)*np.cos(phi)*np.cos(psi))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]))/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    # WN0[5,0] = (1.0*R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.cos(tau) + (-np.sin(phi)*np.cos(psi)*np.cos(theta) - np.sin(psi)*np.cos(phi))*np.sin(tau))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1]) + 1.0*R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.cos(tau) + (np.sin(phi)*np.sin(psi)*np.cos(theta) - np.cos(phi)*np.cos(psi))*np.sin(tau))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0]))/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5

    gammaF1 = -R_hip*omega_hip[0]*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + R_hip*omega_hip[1]*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*(phidot*np.sin(psi)*np.sin(theta) + thetadot*np.cos(psi)) - R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*(-phidot*np.sin(theta)*np.cos(psi) + thetadot*np.sin(psi)) - vbar_hip[2] + vbar_hoop[2]
    gammaF2 = (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])*(R_hip*omega_hip[2]*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 - R_hoop*(phidot*np.cos(theta) + psidot)*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) + R_hoop*(-phidot*np.sin(theta)*np.cos(psi) + thetadot*np.sin(psi))*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi)) - omega_hip[1]*(-R_hip*xbar_hip[2]/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi)) + xbar_hoop[2]) - vbar_hip[0] + vbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 - (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])*(-R_hip*omega_hip[2]*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + R_hoop*(phidot*np.cos(theta) + psidot)*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - R_hoop*(phidot*np.sin(psi)*np.sin(theta) + thetadot*np.cos(psi))*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi)) + omega_hip[0]*(-R_hip*xbar_hip[2]/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi)) + xbar_hoop[2]) - vbar_hip[1] + vbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    gammadotF1 = -R_hip*alpha_hip[0]*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + R_hip*alpha_hip[1]*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 - abar_hip[2] + abar_hoop[2] + phiddot*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*np.sin(psi)*np.sin(theta) + R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*np.sin(theta)*np.cos(psi)) + thetaddot*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*np.cos(psi) - R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*np.sin(psi))
    gammadotF2 = -abar_hip[0]*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + abar_hip[1]*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + abar_hoop[0]*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 - abar_hoop[1]*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 - alpha_hip[0]*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])*(-R_hip*xbar_hip[2]/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi)) + xbar_hoop[2])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + alpha_hip[1]*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])*(R_hip*xbar_hip[2]/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 - R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi)) - xbar_hoop[2])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + alpha_hip[2]*(R_hip*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**1.0 + R_hip*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**1.0) + phiddot*((-R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*np.cos(theta) - R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi))*np.sin(theta)*np.cos(psi))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 - (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*np.cos(theta) - R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi))*np.sin(psi)*np.sin(theta))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5) + psiddot*(-R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 - R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5) + thetaddot*(R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])*np.sin(psi)/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])*np.cos(psi)/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5)

    WF[0,0] = 0
    WF[1,0] = 0
    WF[2,0] = 1
    WF[3,0] = 0
    WF[4,0] = R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*np.cos(psi) - R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*np.sin(psi)
    WF[5,0] = R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*np.sin(psi)*np.sin(theta) + R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*np.sin(theta)*np.cos(psi)

    WF[0,1] = (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    WF[1,1] = -(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    WF[2,1] = 0
    WF[3,1] = -R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 - R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    WF[4,1] = R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])*np.sin(psi)/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 + R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])*np.cos(psi)/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5
    WF[5,1] = (-R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau))*np.cos(theta) - R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi))*np.sin(theta)*np.cos(psi))*(R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5 - (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau))*np.cos(theta) - R_hoop*(np.sin(phi)*np.sin(theta)*np.cos(tau) + np.sin(tau)*np.sin(theta)*np.cos(phi))*np.sin(psi)*np.sin(theta))*(R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])/(xbar_hip[2]**2 + (R_hoop*((-np.sin(phi)*np.sin(psi) + np.cos(phi)*np.cos(psi)*np.cos(theta))*np.sin(tau) + (np.sin(phi)*np.cos(psi)*np.cos(theta) + np.sin(psi)*np.cos(phi))*np.cos(tau)) - xbar_hip[1] + xbar_hoop[1])**2 + (R_hoop*((-np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta))*np.sin(tau) + (-np.sin(phi)*np.sin(psi)*np.cos(theta) + np.cos(phi)*np.cos(psi))*np.cos(tau)) - xbar_hip[0] + xbar_hoop[0])**2)**0.5

    gammaF = np.array([gammaF1, gammaF2])
    gammadotF = np.array([gammadotF1, gammadotF2])
    
    return gN, gNdot, gNddot, WN, gammaF, gammadotF, WF

def combine_contact_constraints(q,u,a):
    # combine all gap distance, slip speed functions and the gradients and derivatives from both contacts

    # get the minimizing values
    tau = get_minimizing_tau(q,xbar_hip[iter,:])
    
    # Contact constraints and constraint gradients
    # initializing constraints
    gN = np.zeros(nN)
    gammaF = np.zeros(nF)
    # initialize constraint derivatives
    gNdot = np.zeros(nN)
    gNddot = np.zeros(nN)
    gammadotF = np.zeros(nF)
    # initializing constraint gradients
    WN = np.zeros((ndof, nN))
    WF = np.zeros((ndof, nF))

    if np.size(tau) == 2:  # two local minima
        gN[0], gNdot[0], gNddot[0], WN[:,0], gammaF[gammaF_lim[0,:]], gammadotF[gammaF_lim[0,:]], WF[:,gammaF_lim[0,:]] = get_contact_constraints(q,u,a,tau[0],xbar_hip[iter,:],vbar_hip[iter,:],abar_hip[iter,:])
        gN[1], gNdot[1], gNddot[1], WN[:,1], gammaF[gammaF_lim[1,:]], gammadotF[gammaF_lim[1,:]], WF[:,gammaF_lim[1,:]] = get_contact_constraints(q,u,a,tau[1],xbar_hip[iter,:],vbar_hip[iter,:],abar_hip[iter,:])
        # saving values
        # minimizing_tau_save[:,iter] = tau 
        
    elif np.size(tau) == 1:
        # This case is rare if the hoop is not initialized to a horizontal configuration
        gN[0], gNdot[0], gNddot[0], WN[:,0], gammaF[gammaF_lim[0,:]], gammadotF[gammaF_lim[0,:]], WF[:,gammaF_lim[0,:]] = get_contact_constraints(q,u,a,tau[0],xbar_hip[iter,:],vbar_hip[iter,:],abar_hip[iter,:])
        gN[1] = 1   # >0, no contact, we don't worry about other values
        # saving values
        # minimizing_tau_save[0,iter] = tau.item()
        # CONCERN: nonsmooth jumps in contact functions
    else:
        # raise error
        # this error might be raised when the hoop is horizontal and centered at the hip, in which case there is no contact between hoop and hip and code proceeds normally
        raise NoLocalMinima()

    return gN, gNdot, gNddot, WN, gammaF, gammadotF, WF



def get_R(X,prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF,*index_sets):
    """Calculates the residual"""
    global corners_save, leaves_counter, iter, ntime

    [prev_a,_,_,_,_,_,_,_,_,_,prev_lambdaN,_,prev_lambdaF] = get_X_components(prev_X)
    [a,U,Q,Kappa_g,Lambda_g,lambda_g,Lambda_gamma,lambda_gamma,
     KappaN,LambdaN,lambdaN,LambdaF,lambdaF] = get_X_components(X)
    
    # AV - Auxiliary Variables [abar, lambdaNbar, lambdaFbar]
    prev_abar = prev_AV[0:ndof]
    prev_lambdaNbar = prev_AV[ndof:ndof+nN]
    prev_lambdaFbar = prev_AV[ndof+nN:ndof+nN+nF]

    # auxiliary variables update
    # eq. 49
    abar = (alpha_f*prev_a+(1-alpha_f)*a-alpha_m*prev_abar)/(1-alpha_m)
    # eq. 96
    lambdaNbar = (alpha_f*prev_lambdaN+(1-alpha_f)*lambdaN-alpha_m*prev_lambdaNbar)/(1-alpha_m)
    # eq. 114
    lambdaFbar = (alpha_f*prev_lambdaF+(1-alpha_f)*lambdaF-alpha_m*prev_lambdaFbar)/(1-alpha_m)

    AV = np.concatenate((abar,lambdaNbar,lambdaFbar),axis=None)

    # velocity update (73)
    u = prev_u+dtime*((1-gama)*prev_abar+gama*abar)+U
    # position update (73)
    q = prev_q+dtime*prev_u+dtime**2/2*((1-2*beta)*prev_abar+2*beta*abar)+Q

    # bilateral constraints at position level
    g = np.zeros((ng))
    gdot = np.zeros((ng))
    gddot = np.zeros((ng))
    Wg = np.zeros((ndof,ng))

    # bilateral constraints at velocity level
    gamma = np.zeros((ngamma))
    gammadot = np.zeros((ngamma))
    Wgamma = np.zeros((ndof,ngamma))

    # normal gap distance constraints and some frictional quantities
    gN, gNdot, gNddot, WN, gammaF, gammaFdot, WF = combine_contact_constraints(q,u,a)

    # eq. 44
    ksiN = gNdot+eN*prev_gNdot
    # discrete normal percussion eq. 95
    PN = LambdaN+dtime*((1-gama)*prev_lambdaNbar+gama*lambdaNbar)
    # eq. 102
    Kappa_hatN = KappaN+dtime**2/2*((1-2*beta)*prev_lambdaNbar+2*beta*lambdaNbar)

    # eq. 48
    ksiF = gammaF+eN*prev_gammaF
    # eq. 113
    PF = LambdaF+dtime*((1-gama)*prev_lambdaFbar+gama*lambdaFbar)    
        
    Rs = np.concatenate(([M@a-force-Wg@lambda_g-Wgamma@lambda_gamma-WN@lambdaN-WF@lambdaF],
               [M@U-Wg@Lambda_g-Wgamma@Lambda_gamma-WN@LambdaN-WF@LambdaF],
               [M@Q-Wg@Kappa_g-WN@KappaN-dtime/2*(Wgamma@Lambda_gamma+WF@LambdaF)],
               g,
               gdot,
               gddot,
               gamma,
               gammadot),axis=None)
    
    # Contact residual Rc
    R_KappaN = np.zeros(nN)   # (129)
    R_LambdaN = np.zeros(nN)
    R_lambdaN = np.zeros(nN)
    R_LambdaF = np.zeros(nF)  # (138)
    R_lambdaF = np.zeros(nF)  # (142)

    if index_sets == ():
        A = np.zeros(nN, dtype=int)
        B = np.zeros(nN, dtype=int)
        C = np.zeros(nN, dtype=int)
        D = np.zeros(nN, dtype=int)
        E = np.zeros(nN, dtype=int)

        for i in range(nN):
            # check for contact if blocks are not horizontally detached
            if r*gN[i] - Kappa_hatN[i] <=0:
                A[i] = 1
                if np.linalg.norm(r*ksiF[gammaF_lim[i,:]]-PF[gammaF_lim[i,:]])<=mu_s*(PN[i]):
                    # D-stick
                    D[i] = 1
                    if np.linalg.norm(r*gammaFdot[gammaF_lim[i,:]]-lambdaF[gammaF_lim[i,:]])<=mu_s*(lambdaN[i]):
                        # E-stick
                        E[1] = 1
                if r*ksiN[i]-PN[i] <= 0:
                    B[i] = 1
                    if r*gNddot[i]-lambdaN[i] <= 0:
                        C[i] = 1
    else:
        A = index_sets[0]
        B = index_sets[1]
        C = index_sets[2]
        D = index_sets[3]
        E = index_sets[4]

    # calculating contact residual
    for k in range(nN):
        if A[k]:
            R_KappaN[k] = gN[k]
            if D[k]:
                R_LambdaF[gammaF_lim[k,:]] = ksiF[gammaF_lim[k,:]]
                if E[k]:
                    R_lambdaF[gammaF_lim[k,:]] = gammaFdot[gammaF_lim[k,:]]
                else:
                    R_lambdaF[gammaF_lim[k,:]] = lambdaF[gammaF_lim[k,:]]+mu_k*lambdaN[k]*np.sign(gammaFdot[gammaF_lim[k,:]])                    
            else:
                R_LambdaF[gammaF_lim[k,:]] = PF[gammaF_lim[k,:]]+mu_k*PN[k]*np.sign(ksiF[gammaF_lim[k,:]])
                R_lambdaF[gammaF_lim[k,:]] = lambdaF[gammaF_lim[k,:]]+mu_k*lambdaN[k]*np.sign(gammaF[gammaF_lim[k,:]])
        else:
            R_KappaN[k] = Kappa_hatN[k]
            R_LambdaF[gammaF_lim[k,:]] = PF[gammaF_lim[k,:]]
            R_lambdaF[gammaF_lim[k,:]] = lambdaF[gammaF_lim[k,:]]
        # (132)
        if B[k]:
            R_LambdaN[k] = ksiN[k]
        else:
            R_LambdaN[k] = PN[k]
        # (135)
        if C[k]:
            R_lambdaN[k] = gNddot[k]
        else:
            R_lambdaN[k] = lambdaN[k]


    Rc = np.concatenate((R_KappaN, R_LambdaN, R_lambdaN, R_LambdaF, R_lambdaF),axis=None)
    
    R = np.concatenate([Rs, Rc],axis=None)


    if index_sets == ():
        # in this case, get_R is called to calculate the actual residual, not as part of calculating the Jacobian
        print(f"A={A}")
        print(f"B={B}")
        print(f"C={C}")
        print(f"D={D}")
        print(f"E={E}")
        return R, AV, q, u, gNdot, gammaF, A, B, C, D, E
    else:
        # in this case, get_R is called as part of calculating the Jacobian for fixed contact regions
        return R, AV, q, u, gNdot, gammaF

def get_R_J(X,prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF,*fixed_contact):
    global A_save, B_save, C_save, D_save, E_save
    global iter

    epsilon = 1e-6
    fixed_contact_regions = False

    if fixed_contact != ():
        # here, the contact is fixed if a solve_bifurcation is being run
        fixed_contact = fixed_contact[0]
        fixed_contact_regions = True
        A = fixed_contact[0:nN]
        B = fixed_contact[nN:2*nN]
        C = fixed_contact[2*nN:3*nN]
        D = fixed_contact[3*nN:3*nN+nN]
        E = fixed_contact[3*nN+nN:3*nN+2*nN]
        R, AV, q, u, gNdot, gammaF =  get_R(X,prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF, A, B, C, D, E)
    else:
        R, AV, q, u, gNdot, gammaF, A, B, C, D, E = get_R(X,prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF)
        contacts_nu = np.concatenate((A,B,C,D,E),axis=None)

    # Initializing the Jacobian
    J = np.zeros((nX,nX))
    I = np.identity(nX)

    A_save[:,iter] = A
    B_save[:,iter] = B
    C_save[:,iter] = C
    D_save[:,iter] = D
    E_save[:,iter] = E

    # Constructing the Jacobian column by column
    for i in range(nX):
        # print(i)
        R_plus_epsilon,_,_,_,_,_ = get_R(X+epsilon*I[:,i],prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF, A, B, C, D, E)
        J[:,i] = (R_plus_epsilon-R)/epsilon

    if fixed_contact_regions:
        return R, AV, q, u, gNdot, gammaF, J
    else:
        # return the contact regions 'contacts_nu' to be saved in case they are needed (in the case of unconverged iterations)
        return R, AV, q, u, gNdot, gammaF, J, contacts_nu

def update(prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF,*fixed_contact):
    """Takes components at time t and return values at time t+dt"""
    global ntime, iter, n_tau
    
    nu = 0
    X = prev_X
    
    if fixed_contact != ():
        # the contact region is fixed if solve_bifuration is calling update 
        # the fixed_contact data is inputted into get_R_J
        fixed_contact = fixed_contact[0]
        fixed_contact_regions = True
        print(f"Fixed contact fixed: {fixed_contact}")
    else:
        fixed_contact_regions = False

    try:
        if fixed_contact_regions == True:
            R, AV, q, u, gNdot, gammaF, J = get_R_J(X,prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF,fixed_contact)
        else:
            R, AV, q, u, gNdot, gammaF, J, contacts_nu = get_R_J(X,prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF)
            contacts = np.zeros((MAXITERn+1,3*nN+2*nN),dtype=int)
            contacts[nu,:] = contacts_nu
        norm_R = np.linalg.norm(R,np.inf)
        print(f"nu = {nu}")
        print(f"norm(R) = {norm_R}")

        while np.abs(np.linalg.norm(R,np.inf))>tol_n and nu<MAXITERn:
            # Newton Update
            X = X-np.linalg.solve(J,R)
            # Calculate new EOM and residual
            nu = nu+1
            if fixed_contact_regions:
                R, AV, q, u, gNdot, gammaF, J = get_R_J(X,prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF,fixed_contact)
            else:
                R, AV, q, u, gNdot, gammaF, J, contacts_nu = get_R_J(X,prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF)
                contacts[nu,:] = contacts_nu
            norm_R = np.linalg.norm(R,np.inf)
            print(f"nu = {nu}")
            print(f"norm(R) = {norm_R}")

            if norm_R>10**10:
                # the Jacobian is blowing up
                # (I am assuming this is happening because contact region is fixed, 
                # update is being called from within solve_bifuration)
                raise TypeError
        
        if nu == MAXITERn:
            print(f"No Convergence for nu = {nu} at rho_inf = {rho_inf}")
            raise MaxNewtonIterAttainedError

    except MaxNewtonIterAttainedError as e:
        if fixed_contact_regions is False:
            # if unique contact regions were already determined, don't recalculate them
            unique_A = np.unique(contacts[:,0:nN], axis=0)
            do_not_unpack = True    
            # because if the number of contact regions is 6 which is the original number
            # of outputs of update, each row of unique contacts will be assinged as an output variable
            # if n_tau/int(1/tol_n) <100: # don't keep incrementing infinitely. without the if statement, anytime you don't converge, and you increase rho_inf, you will increase n_tau
            #     n_tau = n_tau*10

            print(f"Max Newton iterations is attained. Unique A contacts are {unique_A}.")

            unique_contacts = np.empty((0, 10))

            if np.any(np.all(unique_A == np.array([0,0]), axis=1)):    # check if [0,0] is in 'A'
                unique_contacts = np.vstack([unique_contacts,unique_contacts_a])
            if np.any(np.all(unique_A == np.array([1,0]), axis=1)):    # check if [1,0] is in 'A'
                unique_contacts = np.vstack([unique_contacts,unique_contacts_b])
            if np.any(np.all(unique_A == np.array([0,1]), axis=1)):    # check if [0,1] is in 'A'
                unique_contacts = np.vstack([unique_contacts,unique_contacts_c])
            if np.any(np.all(unique_A == np.array([1,1]), axis=1)):    # check if [1,1] is in 'A'
                unique_contacts = np.vstack([unique_contacts,unique_contacts_d])


            return unique_contacts, do_not_unpack
        return 
    except np.linalg.LinAlgError as e:
        if norm_R>10**10:
            # the Jacobian is blowing up
            # (I am assuming this is happening because contact region is fixed, 
            # update is being called from within solve_bifuration)
            raise TypeError
        else:
            # the Jacobian matrix is singular, not invertable
            print(e)
            # increment rho_inf        
            update_rho_inf()
            # calling function recursively
            update(prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF,fixed_contact)
    except Exception as e:
        # any other exception
        raise e
    
    return X,AV,q,u,gNdot,gammaF

def update_rho_inf():
    global rho_inf, alpha_m, alpha_f, gama, beta 
    rho_inf = rho_inf+0.05  #0.01
    print(rho_inf)
    if np.abs(rho_inf - rho_infinity_initial) < 0.001:
        print("possibility of infinite loop")
        raise RhoInfInfiniteLoop
    if rho_inf > 1.001:
        rho_inf = 0
    # eq. 72
    alpha_m = (2*rho_inf-1)/(rho_inf+1)
    alpha_f = rho_inf/(rho_inf+1)
    gama = 0.5+alpha_f-alpha_m
    beta = 0.25*(0.5+gama)**2

def get_X_components(X):
    a = X[0:ndof]
    U = X[ndof:2*ndof]
    Q = X[2*ndof:3*ndof]
    Kappa_g = X[3*ndof:3*ndof+ng]
    Lambda_g = X[3*ndof+ng:3*ndof+2*ng]
    lambda_g = X[3*ndof+2*ng:3*ndof+3*ng]
    Lambda_gamma = X[3*ndof+3*ng:3*ndof+3*ng+ngamma]
    lambda_gamma = X[3*ndof+3*ng+ngamma:3*ndof+3*ng+2*ngamma]
    Kappa_N = X[3*ndof+3*ng+2*ngamma:3*ndof+3*ng+2*ngamma+nN]
    Lambda_N = X[3*ndof+3*ng+2*ngamma+nN:3*ndof+3*ng+2*ngamma+2*nN]
    lambda_N = X[3*ndof+3*ng+2*ngamma+2*nN:3*ndof+3*ng+2*ngamma+3*nN]
    Lambda_F = X[3*ndof+3*ng+2*ngamma+3*nN:3*ndof+3*ng+2*ngamma+3*nN+nF]
    lambda_F = X[3*ndof+3*ng+2*ngamma+3*nN+nF:3*ndof+3*ng+2*ngamma+3*nN+2*nF]
    return a,U,Q,Kappa_g,Lambda_g,lambda_g,Lambda_gamma,lambda_gamma,\
        Kappa_N,Lambda_N,lambda_N,Lambda_F,lambda_F

def increment_saved_arrays():
    global q_save, u_save, X_save, gNdot_save, gammaF_save, AV_save, corners_save
    
    save_arrays()

    # increment saved arrays
    q_save_addition = np.tile(q_save[leaves_counter,:,:],(1,1,1))
    q_save = np.vstack((q_save,q_save_addition))
    u_save_addition = np.tile(u_save[leaves_counter,:,:],(1,1,1))
    u_save = np.vstack((u_save,u_save_addition))
    X_save_addition = np.tile(X_save[leaves_counter,:,:],(1,1,1))
    X_save = np.vstack((X_save,X_save_addition))
    gNdot_save_addition = np.tile(gNdot_save[leaves_counter,:,:],(1,1,1))
    gNdot_save = np.vstack((gNdot_save,gNdot_save_addition))
    gammaF_save_addition = np.tile(gammaF_save[leaves_counter,:,:],(1,1,1))
    gammaF_save = np.vstack((gammaF_save,gammaF_save_addition))
    AV_save_addition = np.tile(AV_save[leaves_counter,:,:],(1,1,1))
    AV_save = np.vstack((AV_save,AV_save_addition))

def solve(iter_start):
    global q_save, u_save, X_save, gNdot_save, gammaF_save, AV_save, corners_save
    global leaves_counter
    global iter
    global rho_infinity_initial, rho_inf
    global n_tau


    fixed_contact_regions = False
    increment_leaves = True

    # f.write(f'Running solve starting from iteration at leaf {leaves_counter}\n')
    g.write(f'{iter_start}-')

    prev_X = X_save[leaves_counter,:,iter_start-1]
    prev_AV = AV_save[leaves_counter,:,iter_start-1]
    prev_q = q_save[leaves_counter,:,iter_start-1]
    prev_u = u_save[leaves_counter,:,iter_start-1]
    prev_gNdot = gNdot_save[leaves_counter,:,iter_start-1]
    prev_gammaF = gammaF_save[leaves_counter,:,iter_start-1]
    iter = iter_start
    # for iter in range(iter_start,ntime):
    while iter<ntime:
        print(f"iteration {iter}")

        current_time = time.time()
        if current_time-start_time>(3600*max_hours):
            f.write(f'Program quit because max execution time {max_hours} hours was exceeded.')
            raise MaxHoursAttained
            # instead set ntime = iter to reduce ntime instead of directly quitting program

        # f.write(f'Iteration {iter}\n') 

        try:
            X,AV,q,u,gNdot,gammaF = update(prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF)
            # this line will return a value error if the MaxNewtonIterAttainedError exception was handeled in update

            prev_X = X
            prev_AV = AV
            prev_q = q
            prev_u = u
            prev_gNdot = gNdot
            prev_gammaF = gammaF

            q_save[leaves_counter,:,iter] = prev_q
            u_save[leaves_counter,:,iter] = prev_u
            X_save[leaves_counter,:,iter] = prev_X
            gNdot_save[leaves_counter,:,iter] = prev_gNdot
            gammaF_save[leaves_counter,:,iter] = prev_gammaF
            AV_save[leaves_counter,:,iter] = prev_AV

            # reset initial value
            rho_infinity_initial = rho_inf 

        except ValueError as e:
            unique_contacts,_ = update(prev_X,prev_AV,prev_q,prev_u,prev_gNdot,prev_gammaF)
            # f.write(f'Detected a bifurcation at leaf {leaves_counter} at iter {iter}\n')
            g.write(f'{iter}\n')
            solve_bifurcation(iter,unique_contacts)
            increment_leaves = False
            break   # this break is important 
        except Exception as e:
            # f.write(f'Bifurcation branch did not pan out for leaf {leaves_counter} at {iter}\n') 
            raise e

        iter = iter+1

        if iter == 190:
            print('190')

        if iter%25 == 0:
            save_arrays()

    if increment_leaves == True:

        g.write(f'end (leaf {leaves_counter})\n')
        
        increment_saved_arrays()

        # q_save_shape = np.shape(q_save)
        # f.write(f'The shape of q_save was incremented to {q_save_shape}\n')

        leaves_counter = leaves_counter + 1
        # f.write(f'leaves counter incremented to leaf {leaves_counter}\n')
        print(f'leaves_counter = {leaves_counter}')

        # if leaves_counter>max_leaves:
        #     f.write(f'Program quit because max number of leaves that is {max_leaves} was exceeded.\n')
        #     raise Exception

    return

global bif_counter  # used in bifurcation log
bif_counter = 0

def solve_bifurcation(iter_bif,*fixed_contact_region_params):
    global q_save, u_save, X_save, gNdot_save, gammaF_save, AV_save
    global leaves_counter
    global iter
    global bif_counter
    bif_counter +=1

    global increment_leaves
    increment_leaves = True # I think this is unneccessary

    # f.write(f'Running solve_bifurcations at iter_bif {iter_bif} and leaf {leaves_counter}\n') 
    
    # fixed_contact_regions = True
    unique_contacts = fixed_contact_region_params[0]
    n_unique_contacts = np.shape(unique_contacts)[0]

    # f.write(f'The number of unique contacts is {n_unique_contacts}\n')

    nonconvergence_counter = 0

    for k in range(n_unique_contacts):
        iter = iter_bif

        print(f"k = {k}")
        g.write("     |"*bif_counter)
        g.write(f'__ {k+1} of {n_unique_contacts}  ')
        
        try:
            fixed_contact  = unique_contacts[k,:]
            X,AV,q,u,gNdot,gammaF = update(X_save[leaves_counter,:,iter_bif-1],AV_save[leaves_counter,:,iter_bif-1],
                                       q_save[leaves_counter,:,iter_bif-1],u_save[leaves_counter,:,iter_bif-1],
                                       gNdot_save[leaves_counter,:,iter_bif-1],gammaF_save[leaves_counter,:,iter_bif-1],
                                       fixed_contact)

            prev_X = X
            prev_AV = AV
            prev_q = q
            prev_u = u
            prev_gNdot = gNdot
            prev_gammaF = gammaF

            q_save[leaves_counter,:,iter_bif] = prev_q
            u_save[leaves_counter,:,iter_bif] = prev_u
            X_save[leaves_counter,:,iter_bif] = prev_X
            gNdot_save[leaves_counter,:,iter_bif] = prev_gNdot
            gammaF_save[leaves_counter,:,iter_bif] = prev_gammaF
            AV_save[leaves_counter,:,iter_bif] = AV

            # f.write(f'{k}-th unique contact convergence successfull\n')            

            solve(iter_bif+1)

            if leaves_counter > max_leaves:
                break

        except TypeError as e:       
            # make a provision for if we always passed and never converged.
            # f.write(f'{k}-th unique contact convergence unsuccessfull\n') 
            g.write('unsuccessful\n')   
            nonconvergence_counter = nonconvergence_counter+1
            # f.write(f'nonconvergence_counter = {nonconvergence_counter}\n')
            # num_bif_contacts[leaves_counter,3] = num_bif_contacts[leaves_counter,3]-1
            if nonconvergence_counter == n_unique_contacts:
                # exception raised when None of the fixed contact regions converged
                # raise Exception
                global MAXITERn
                nonconvergence_counter = 0
                if MAXITERn < 10:  # INCOMPLETE, TO BE FIXED
                    # try to increase number of iterations
                    MAXITERn = 200
                    solve_bifurcation(iter_bif,unique_contacts)
                else:
                    try:
                        update_rho_inf()
                        solve_bifurcation(iter_bif,unique_contacts)
                    except:
                        # we cannot update rho_inf anymore
                        # we need to abandon this leaf  
                        g.write(f'bifurcation convergence failed\n')
                        pass
                        raise Exception
                # solve_bifurcation(iter_bif,unique_contacts) # maybe wrong, remove
            else:
                pass

    bif_counter = bif_counter-1
    # increment_leaves = False

    return 

X0 = np.zeros(nX)

# initial auxiliary variable
nAV = ndof+nN+nF
AV0 = np.zeros(nAV)

# initial position
q0 = np.array([0, 0, 1, 0, 0, 0])
# initial velocity
u0 = np.array([0, 0, 0, 0, 0, 1])

# initial normal gap speeds
gNdot0 = np.zeros(nN)   # starting from rest

# inital slip speeds
gammaF0 = np.zeros(nF)  # starting from rest

prev_X = X0
prev_AV = AV0
prev_q = q0
prev_u = u0
prev_gNdot = gNdot0
prev_gammaF = gammaF0

q_save = np.zeros((1,ndof,ntime))
u_save = np.zeros((1,ndof,ntime))
X_save = np.zeros((1,nX,ntime))
gNdot_save = np.zeros((1,nN,ntime))
gammaF_save = np.zeros((1,nF,ntime))
AV_save = np.zeros((1,ndof+nN+nF,ntime))
corners_save = np.zeros((1,nN,ntime))

q_save[0,:,0] = prev_q
u_save[0,:,0] = prev_u
X_save[0,:,0] = prev_X
gNdot_save[0,:,0] = prev_gNdot
gammaF_save[0,:,0] = prev_gammaF
AV_save[0,:,0] = prev_AV

A_save = np.zeros((nN,ntime))
B_save = np.zeros((nN,ntime))
C_save = np.zeros((nN,ntime))
D_save = np.zeros((nN,ntime))
E_save = np.zeros((nN,ntime))

# parameters for bifurcations
fixed_contact_regions = False   # COMMENT THIS AND SEE IF NECESSARY

leaves_counter = 0
# running the code!
try:
    f.write(f"Total duration of simulation: {tf} sec.\n\n")
    solve(1)
    # removing last added leaf_counter
    leaves_counter = leaves_counter-1
    # f.write(f'leaves_counter decremented to {leaves_counter}\n')
    # removing the last added block to q_save
    q_save = q_save[0:np.shape(q_save)[0]-1,:,:]
    # f.write(f'q_save decremented to {np.shape(q_save)}\n')
except: 
    f.write(f"Failure at iteration {iter} while calculating leaf {leaves_counter} at bifurcation level {bif_counter}.\n")
finally:
    f.write(f"Number of converged leaves: {leaves_counter}\n")        
    end_time = time.time()
    execution_time = end_time-start_time
    print("Execution time:", execution_time, "seconds")
    g.write(f"Execution time: {execution_time} seconds.\n")
    f.write(f"Execution time: {execution_time} seconds.\n")
    f.write("\n")

    f.close()
    g.close()

    
    file_name = str(f'{output_path}/q.mat')
    scipy.io.savemat(file_name,dict(q=q_save))
    file_name_corners = str(f'{output_path}/corners.mat')
    scipy.io.savemat(file_name_corners,dict(corners=corners_save))

    print("Saved.")